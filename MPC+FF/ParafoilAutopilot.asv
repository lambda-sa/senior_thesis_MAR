classdef ParafoilAutopilot < handle
    % PARAFOILAUTOPILOT
    % 誘導(Guidance)と制御(Control)を統合した自律飛行クラス
    %
    % [概要]
    % Plannerが作成した軌道データを読み込み、現在の機体状態(位置・速度・風)に基づいて
    % 最適なトグル操作量(delta_R, delta_L)を計算して出力します。
    %
    % [座標系の定義]
    % - NED座標系 (North-East-Down): X=北, Y=東, Z=下
    % - 方位角(Psi): 北を0として時計回り(CW)が正
    %
    % [誘導ロジックの特徴]
    % 1. Loiter (待機): 位相角ベースの解析的ベクトル場 (指定論文の式)
    % 2. Mission (着陸): 点群に対するウィンドウ探索 + General Path VF
    
    properties
        % --- 機体・空力パラメータ ---
        Params       % 全パラメータ構造体 (質量, 翼面積, 空力係数など)
        Yaw_Factor   % トグル操作量 -> ヨーモーメントへの変換係数 (FF制御用)
        
        % --- ゲイン設定 (要調整) ---
        Gains
        % .k_vf_loiter : Loiter時の収束ゲイン (小さい=マイルド, 大きい=急激)
        % .k_vf_mission: Mission時の収束ゲイン (着陸精度に直結)
        % .chi_inf     : 無限遠での最大進入角 [rad] (通常 pi/2 = 90度)
        % .kp_psi      : [制御] ヘディング誤差 -> 目標バンク角 の比例ゲイン
        % .kp_phi      : [制御] バンク角誤差 -> トグル操作量 の比例ゲイン
        
        % --- 軌道データ (import_mission_dataでセット) ---
        CurrentMode     % 現在のモード: 'Loiter' or 'Mission'
        
        % Loiter用: 円軌道の幾何学情報
        LoiterParams    % .xc, .yc (中心), .R (半径), .lambda (+1:右回り, -1:左回り)
        
        % Mission用: 点群データ (Entry -> Dubins -> Final)
        MissionPath     % .x, .y, .z, .chi(接線), .kappa(曲率), .num_points
        LastIndex       % 前回の最近傍点インデックス (探索高速化 & 逆走防止用)
        WindowSize      % 前方探索ウィンドウサイズ (点の個数)
        
        % --- 状態管理 ---
        IsReady         % 初期化完了フラグ
        % ★追加: 状態管理用
        PsiErrIntegral=0;  % ヘディング誤差の積分値 (I制御用)
        LastUpdateTime=-1;        % 前回の呼び出し時刻 (dt計算用)
        UpdateInterval = 0.05; % 制御周期 (20Hz)
        
        % ★追加: ホールド用の前回値 (Zero-Order Hold)
        LastDeltaR = 0;
        LastDeltaL = 0;

        % ★追加: 数値微分用
        LastPsiCmd = NaN;  % 前回の目標ヘディング
    end
    
    methods
        function obj = ParafoilAutopilot(params)
            % コンストラクタ: パラメータの展開と初期設定
            obj.Params = params;
            obj.IsReady = false;
            
            % -----------------------------------------------------
            % 1. トグル操作量のFF係数 (Yaw_Factor) の計算
            % -----------------------------------------------------
            % 「ある旋回レート(r)を出したい時、どれくらいトグルを引けばいいか？」
            % を、線形化モデルのモーメント釣り合い式から逆算するための係数です。
            % 式: delta_a_req = Yaw_Factor * (g / V^2) * sin(phi)
            
            if isfield(params, 'prop'), b = params.prop.b; else, b = params.b; end
            if isfield(params, 'params')
                d = params.params.d; % 吊り下げ長
                Cn_r = params.params.C_n_r; % ヨー減衰係数
                Cn_da = params.params.C_n_delta_a; % 舵効き係数
            else
                d = params.d; Cn_r = params.C_n_r; Cn_da = params.C_n_delta_a;
            end
            
            % 物理的意味: (減衰項) / (操舵効力項)
            obj.Yaw_Factor = -d * b * Cn_r / (2 * Cn_da);
            
            % -----------------------------------------------------
            % 2. 制御ゲインのデフォルト設定
            % -----------------------------------------------------
            obj.Gains.k_vf_loiter  = 0.01;   % Loiterは滑らかさ重視 (低め)
            obj.Gains.chi_inf      = pi/3;   % 最大90度でコースに戻る
            obj.Gains.k_vf_mission = 0.10;   % Missionは追従精度重視 (高め)
            
            obj.Gains.kp_psi       = 0;    % 方位ズレ1度に対し、バンクkp_psi度指令
            % ★追加: Iゲイン設定 (デフォルト値)
            % Pゲイン(1.5)の 1/5 ~ 1/10 程度から始めるのが定石
            obj.Gains.ki_psi = 0;
            % ★追加: Dゲイン (Yaw Damper)
            % 目安: Pゲインの 1/3 ~ 1/2 程度
            % 役割: 旋回速度(r)に比例して反対方向に舵を当てる（ダンピング）
            obj.Gains.kd_psi       = 0;


            obj.Gains.kp_phi       = 0;    % バンクズレ1radに対し、トグル0.5操作
            
            % 変数初期化
            obj.PsiErrIntegral = 0;
            obj.LastUpdateTime = -1;

            % 内部変数の初期化
            obj.CurrentMode = 'Loiter';
            obj.WindowSize = 10; % 探索範囲は前方100点まで
            obj.LastIndex = 1;
        end
        
        % =========================================================
        % データ取り込み: Plannerの出力結果を解釈する
        % =========================================================
        function import_mission_data(obj, planner)
            % ParafoilPathPlannerClothoid の結果(ResultData)を読み込み、
            % 誘導則が扱いやすい形に変換して保持します。
            
            % 風を考慮した計画データがあればそれを優先
            if isprop(planner, 'ResultDataWind') && ~isempty(planner.ResultDataWind)
                d = planner.ResultDataWind;
            else
                d = planner.ResultData;
            end
            if isempty(d), error('Planner has no data.'); end
            
            % --- A. Loiterデータの解析 (点群 -> 円パラメータ) ---
            % Loiterは点群を追うより、中心と半径から解析的に計算する方が
            % 計算負荷が低く、かつ真円に近い滑らかな旋回ができます。
            if isfield(d, 'loiter') && length(d.loiter.x) > 10
                lx = d.loiter.x; ly = d.loiter.y;
                
                % 最大値・最小値から中心と半径を推定
                xc = (min(lx) + max(lx)) / 2;
                yc = (min(ly) + max(ly)) / 2;
                R  = (max(lx) - min(lx)) / 2;
                
                % 回転方向(Lambda)の自動判定
                % 始点付近の2つのベクトル外積を用いて判定
                % NED系(X:北, Y:東)における外積 (x1*y2 - x2*y1)
                % 時計回り(CW)なら外積はプラスになる傾向があるが、場所による。
                % 確実な方法: 角度の変化を見る
                ang1 = atan2(ly(1)-yc, lx(1)-xc);
                ang2 = atan2(ly(5)-yc, lx(5)-xc);
                diff = ang2 - ang1;
                % 角度補正 (-pi~piのまたぎ処理)
                if diff > pi, diff = diff - 2*pi; end
                if diff < -pi, diff = diff + 2*pi; end
                
                % NED系では時計回りが「角度増加」なので diff > 0 ならCW
                if diff > 0
                    lambda = 1;  % 右旋回 (Clockwise)
                else
                    lambda = -1; % 左旋回 (Counter-Clockwise)
                end
                
                obj.LoiterParams = struct('xc',xc, 'yc',yc, 'R',R, 'lambda',lambda);
            else
                warning('No Loiter data found.');
                obj.LoiterParams = [];
            end
            
            % --- B. Missionデータの結合 (Entry + Dubins + Final) ---
            % 複雑な経路は「一本の点群」として扱います。
            raw_x=[]; raw_y=[]; raw_z=[]; raw_psi=[];
            phases = {'entry', 'dubins', 'final'}; 
            for i = 1:length(phases)
                p = phases{i};
                if isfield(d, p) && ~isempty(d.(p).x)
                    raw_x = [raw_x, d.(p).x(:)'];
                    raw_y = [raw_y, d.(p).y(:)'];
                    raw_z = [raw_z, d.(p).z(:)'];
                    raw_psi = [raw_psi, d.(p).psi(:)'];
                end
            end
            
            if isempty(raw_x)
                warning('No Mission data found.');
                obj.MissionPath = [];
            else
                % 曲率 (Kappa) の数値再計算
                % Plannerが出力する座標から、数値微分で曲率を求めます。
                % これにより、バンク角のフィードフォワード制御が可能になります。
                dx = gradient(raw_x); dy = gradient(raw_y);
                ds = sqrt(dx.^2 + dy.^2); ds(ds<0.1) = 0.1; % ゼロ割防止
                dpsi = gradient(unwrap(raw_psi));
                
                kappa = dpsi ./ ds; % 曲率定義: d(角度)/d(距離)
                kappa = smoothdata(kappa, 'movmean', 5); % 微分ノイズを除去
                
                obj.MissionPath.x = raw_x;
                obj.MissionPath.y = raw_y;
                obj.MissionPath.z = raw_z;
                obj.MissionPath.chi = unwrap(raw_psi);
                obj.MissionPath.kappa = kappa;
                obj.MissionPath.num_points = length(raw_x);
            end
            
            obj.IsReady = true;
            obj.CurrentMode = 'Loiter'; % 初期モード設定
            obj.LastIndex = 1;
            
            fprintf('[Autopilot] Initialized. Loiter: %s (R=%.1fm), Mission: %d pts.\n', ...
                calc_rot_str(obj.LoiterParams.lambda), obj.LoiterParams.R, obj.MissionPath.num_points);
        end
        
        % モード手動切替 (Schedulerから呼ばれる)
        function set_mode(obj, mode_str)
            if strcmpi(mode_str, 'Loiter') || strcmpi(mode_str, 'Mission')
                if ~strcmpi(obj.CurrentMode, mode_str)
                    obj.PsiErrIntegral = 0; % モードが変わったらリセット
                end
                obj.CurrentMode = mode_str;
            else
                error('Mode must be "Loiter" or "Mission"');
            end
        end
        
        % =========================================================
        % ★★★ メイン更新メソッド (シミュレーション毎ステップ実行) ★★★
        % =========================================================
        function [delta_R, delta_L, log_struct] = update(obj, t, current_state, wind_vec, V_horiz, delta_s_bias)
            % 入力:
            %   current_state : [u, v, w, p, q, r, phi, theta, psi, x, y, z]
            %   wind_vec      : [Wx, Wy, 0] (NED系)
            %   delta_s_bias  : 対称操作量 (高度制御用)
            
            if nargin < 6, delta_s_bias = 0; end
            if ~obj.IsReady, error('Autopilot not initialized.'); end

            if (obj.LastUpdateTime >= 0) && (t - obj.LastUpdateTime < obj.UpdateInterval)
                delta_R = obj.LastDeltaR;
                delta_L = obj.LastDeltaL;
                
                % ログ用のダミー (または前回の値を保存しておく)
                log_struct.mode = obj.CurrentMode;
                log_struct.chi_cmd = 0; % 簡易的
                log_struct.psi_cmd = 0;
                log_struct.phi_cmd = 0;
                log_struct.delta_a = delta_R - delta_L;
                log_struct.psi_err_integ = obj.PsiErrIntegral;
                return; 
            end
            
            % --- ここから下は「更新タイミング」に来た時だけ実行される ---
            
            % 時間刻みの計算 (固定周期とみなして UpdateInterval を使うのが安全)
            dt = obj.UpdateInterval;

            % 状態展開
            phi=current_state(7); theta=current_state(8); psi=current_state(9);
            pos_ned = current_state(10:12);
            
            % 制御ゲイン用のTAS (動圧計算用など) は簡易的に計算
            u=current_state(1); v=current_state(2); w=current_state(3);
            V_tas = sqrt(u^2+v^2+w^2); %あくまで「動圧」の計算法
            
            % -----------------------------------------------------
            % Step 1: 誘導 (Guidance)
            % -----------------------------------------------------
            % 現在位置に基づき、目指すべき「対地コース(Chi)」と「曲率(Kappa)」を計算
            cmd = obj.run_vf_guidance(pos_ned, V_horiz, wind_vec);

            % ★★★ 修正箇所: 変数を確実に定義する ★★★
            chi_cmd = cmd.chi_cmd;

            % 構造体 cmd から psi_cmd を取り出して、ローカル変数にする
            if isfield(cmd, 'psi_cmd')
                psi_cmd = cmd.psi_cmd; 
            else
                % もし古いGuidanceコードが残っていてフィールドがない場合の保険
                psi_cmd = chi_cmd; 
            end
            % -----------------------------------------------------
            % Step 2: 制御目標の計算 (Control Target)
            % -----------------------------------------------------
            % (A) 風補正 (Crab Angle Compensation)
            % VFが出した「対地コース」通りに進むために、機首を何度ずらすべきか？
            
            %{
            % 風向・風速から横風成分を計算
            W_mag = norm(wind_vec(1:2));
            chi_wind = atan2(wind_vec(2), wind_vec(1));
            W_cross = W_mag * sin(chi_cmd - chi_wind); % 進行方向に対する横風
            
            % クラブ角 eta の計算 (sin(eta) = W_cross / V_tas)
            %eta = asin(max(-0.9, min(0.9, W_cross/V_tas)));
            eta = asin(W_cross/V_tas);
            % 最終的な目標ヘディング角
            psi_cmd = chi_cmd - eta;
            %}
            % (B) 目標バンク角の決定
            g = 9.81;
            

            % =========================================================
            % ★★★ 修正: 目標レートからのバンク角逆算 (Rate Command FF) ★★★
            % =========================================================
            
            % 初回起動時の初期化
            if isnan(obj.LastPsiCmd)
                obj.LastPsiCmd = psi_cmd;
            end
            
            % 1. 目標ヘディングの変化量 (微小角)
            % normalize_angle を通すことで 179度 -> -179度 のまたぎ問題を回避
            d_psi_cmd = obj.normalize_angle(psi_cmd - obj.LastPsiCmd);
            
            % 2. 要求旋回レート (Target Yaw Rate)
            rate_req = d_psi_cmd / dt;
            
            % ノイズ対策: レート制限 (例: 15deg/s以上は異常としてクリップ)
            max_rate = deg2rad(15);
            rate_req = max(-max_rate, min(max_rate, rate_req));
            
            % 3. 次回用に保存
            obj.LastPsiCmd = psi_cmd;
            
            % 4. バンク角FFの計算 (定常旋回の仮定)
            % phi = atan( V_tas * rate / g )
            g = 9.81;
            phi_ff = atan( (V_horiz * rate_req) / g );
            %phi_ff = 0;
            
            % =========================================================
             

             % バンク角FF計算にも V_horiz を使うのが物理的に正しい
            %V_turn = V_horiz;
            
            % FB項: ヘディング誤差を埋めるための修正バンク角
            % (PID制御のP項に相当)
            psi_err = obj.normalize_angle(psi_cmd - psi);
            % ★追加: 積分項 (I Control)
            % 積分加算
            obj.PsiErrIntegral = obj.PsiErrIntegral + psi_err * dt;
            
            % ★重要: アンチワインドアップ (Anti-Windup)
            % 積分値が溜まりすぎて制御不能になるのを防ぐため、リミットをかける
            % 例: 積分項だけで出せるバンク角を最大 +/- 15度 (0.26rad) に制限
            integ_limit = deg2rad(20); 
            obj.PsiErrIntegral = max(-integ_limit, min(integ_limit, obj.PsiErrIntegral));

            % ★追加: 角速度 r (Yaw Rate) を取得
            r = current_state(6);

            phi_fb_p = obj.Gains.kp_psi * psi_err;% P項
            phi_fb_i = obj.Gains.ki_psi * obj.PsiErrIntegral;   % I項
            % D項: 旋回速度(r)を抑える (Damping)
            % 符号はマイナス（旋回を止めようとする方向）
            phi_fb_d = -obj.Gains.kd_psi * r;

            phi_fb = phi_fb_p + phi_fb_i + phi_fb_d;
            
            % 合成とリミッター (パラフォイルは45度以上傾けると危険)
            phi_cmd = max(-0.8, min(0.8, phi_ff + phi_fb));
            
            % -----------------------------------------------------
            % Step 3: アクチュエータ操作 (Actuation)
            % -----------------------------------------------------
            % (A) FF項: 定常旋回操作量
            % 空力モデルに基づき、そのバンク角を維持するのに必要なトグル量を予測
            K_dyn = (g / V_tas^2) * cos(theta);
            da_ff = obj.Yaw_Factor * K_dyn * sin(phi_cmd);
            
            % (B) FB項: バンク角追従誤差補正
            % モデル化誤差や外乱でバンク角がズレた分をPID(P)で戻す
            phi_err = phi_cmd - phi;
            da_fb = obj.Gains.kp_phi * phi_err;
            
            % 合計操作量
            da_total = da_ff + da_fb;
            
            % (C) ミキシング (左右トグルへの配分)
            % ブレーキ量(delta_s)をベースに、旋回成分(da_total)を差動で加える
            [delta_R, delta_L] = obj.apply_mixing(da_total, delta_s_bias);
            
            % -----------------------------------------------------
            % ログ出力
            % -----------------------------------------------------

            obj.LastUpdateTime = t;
            obj.LastDeltaR = delta_R;
            obj.LastDeltaL = delta_L;
            
            log_struct.mode = obj.CurrentMode;
            log_struct.chi_cmd = chi_cmd;
            log_struct.psi_cmd = psi_cmd;
            log_struct.phi_cmd = phi_cmd;
            log_struct.kappa_ref = cmd.kappa_ref;
            log_struct.error = cmd.error;
            log_struct.delta_a = da_total;
            log_struct.psi_err_integ = obj.PsiErrIntegral; % デバッグ用に積分値も出力

            % ログ出力に追加しておくと便利
            log_struct.psi_err_p = phi_fb_p;
            log_struct.psi_err_i = phi_fb_i;
            log_struct.psi_err_d = phi_fb_d;

        end
    end
    
    methods (Access = private)
        % =========================================================
        % ★★★ 誘導ロジック (Hybrid Vector Field) ★★★
        % =========================================================
        function cmd = run_vf_guidance(obj, pos, V_horiz, wind_vec)
            % 座標取り出し (NED座標系: x=North, y=East)
            x_north = pos(1); 
            y_east  = pos(2);
            
            % デフォルト
            cmd = struct('chi_cmd',0, 'psi_cmd',0, 'kappa_ref',0, 'error',0);
            
            % -----------------------------------------------------
            % 1. Loiter誘導 (Vector Field)
            % -----------------------------------------------------
            if strcmpi(obj.CurrentMode, 'Loiter')
                if isempty(obj.LoiterParams), return; end
                p = obj.LoiterParams;
                
                % 中心からの相対位置
                dx = x_north - p.xc; 
                dy = y_east  - p.yc;
                dist = sqrt(dx^2 + dy^2);
                
                % [重要] 位相角 phi の計算
                % NED座標系の方位角定義 (北=0, 東=90) に合わせるには atan2(East, North)
                phi_pos = atan2(dy, dx); 
                
                % 正規化誤差 (距離/半径)
                tilde_d = (dist - p.R) / p.R;
                
                % パラメータ
                lambda = p.lambda;  % +1(CW), -1(CCW)
                k = obj.Gains.k_vf_loiter; % 注視距離の逆数に相当
                
                % === 誘導の式 (The Equation) ===
                % Chi_d = phi_pos + lambda * (pi/2 + atan(k * error))
                
                % 1. 基本の接線方向 (円周上にいるとき)
                tangent_dir = phi_pos + lambda * (pi/2);
                
                % 2. 進入角 (Approach Angle)
                % 外側(tilde_d > 0)にいるとき:
                %  CW(lam=1)なら、さらに時計回りに回し込みたい -> プラス加算 (OK)
                %  CCW(lam=-1)なら、さらに反時計に回し込みたい -> マイナス加算 (OK)
                approach_angle = lambda * atan(k * tilde_d);
                
                % 3. 合成
                chi_cmd_val = tangent_dir + approach_angle;
                
                % 結果格納
                cmd.chi_cmd   = obj.normalize_angle(chi_cmd_val);
                cmd.kappa_ref = lambda * (1/p.R); % フィードフォワード用曲率
                cmd.error     = dist - p.R;

            % -----------------------------------------------------
            % 2. Mission誘導 (Path Following)
            % -----------------------------------------------------
            else
                % (既存のコードと同じため省略、ただしatanの項を確認)
                if isempty(obj.MissionPath), return; end
                P = obj.MissionPath;
                
                % 最近傍点探索
                range = obj.LastIndex : min(obj.LastIndex + obj.WindowSize, P.num_points);
                d_sq = (P.x(range) - x_north).^2 + (P.y(range) - y_east).^2;
                [~, min_loc] = min(d_sq);
                idx = range(min_loc);
                obj.LastIndex = idx;
                
                chi_ref = P.chi(idx);
                
                % クロストラックエラー (進行方向に対して右ズレが正)
                dx = x_north - P.x(idx); 
                dy = y_east  - P.y(idx);
                e_cross = -sin(chi_ref)*dx + cos(chi_ref)*dy;
                
                % 誘導式
                % chi_cmd = chi_ref - chi_inf * (2/pi) * atan(k * e)
                % 右にズレてる(e>0)なら、左(-方向)に向けたい
                correction = obj.Gains.chi_inf * (2/pi) * atan(obj.Gains.k_vf_mission * e_cross);
                
                cmd.chi_cmd = obj.normalize_angle(chi_ref - correction);
                cmd.kappa_ref = P.kappa(idx);
                cmd.error = e_cross;
            end
            
            % -----------------------------------------------------
            % 3. 風補正 (Crab Angle) - ここも幾何学的に再確認
            % -----------------------------------------------------
            if V_horiz > 1.0
                if length(wind_vec)>=2, Wx=wind_vec(1); Wy=wind_vec(2); else, Wx=0; Wy=0; end
                
                % 風速ベクトル (NED)
                % 風向 chi_wind = atan2(East, North)
                chi_wind = atan2(Wy, Wx);
                W_mag = norm([Wx, Wy]);
                
                % コースに対する相対風向
                % wind_rel = chi_wind - chi_cmd
                % 正なら「右後ろ」から吹いている
                wind_rel = obj.normalize_angle(chi_wind - cmd.chi_cmd);
                
                % 横風成分 (右から左へ吹く成分が正？)
                % ここをシンプルに考える:
                % 風ベクトル W を、進行方向軸(T)と横軸(N)に分解する。
                % W_cross = W dot N
                % 進行方向ベクトル T = [cos(chi), sin(chi)]
                % 右横ベクトル N = [sin(chi), -cos(chi)] ??? いや NEDだと
                % T = [cos(chi); sin(chi)] (North, East)
                % 右ベクトル N = [sin(chi); -cos(chi)] は間違い。
                % 90度回転行列: [0 1; -1 0] -> N = [sin(chi); -cos(chi)] ?
                
                % もっと直感的に:
                % 機首方位 psi と コース chi の関係:
                % V_g = V_a + W
                % 3角形の正弦定理より:
                % sin(eta) / W = sin(chi - chi_wind) / V_a ... 符号がややこしい
                
                % ★決定版公式★
                % クラブ角 eta = psi - chi
                % sin(eta) = - (W / V_a) * sin(chi - chi_wind)
                
                sin_val = -(W_mag / V_horiz) * sin(cmd.chi_cmd - chi_wind);
                sin_val = max(-0.95, min(0.95, sin_val));
                eta = asin(sin_val);
                
                % よって目標ヘディングは
                cmd.psi_cmd = obj.normalize_angle(cmd.chi_cmd + eta);
                
            else
                cmd.psi_cmd = cmd.chi_cmd;
            end
        end
        
        % --- ユーティリティ関数 ---
        
        function [dR, dL] = apply_mixing(~, da, ds)
            % 操舵ミキシングロジック
            % da (差動成分): 正なら右ターン(右引き)、負なら左ターン(左引き)
            % ds (同相成分): ブレーキ(両方引く)
            
            da = max(-1, min(1, da)); % -1~1に制限
            
            if da > 0
                dR = da + ds; % 右を引く
                dL = ds;
            else
                dR = ds;
                dL = abs(da) + ds; % 左を引く
            end
            
            % 物理的限界 (0=全開, 1=全閉)
            dR = max(0, min(1, dR)); 
            dL = max(0, min(1, dL));
        end
        
        function a = normalize_angle(~, a)
            % 角度を -pi ~ pi の範囲に正規化
            a = mod(a + pi, 2*pi) - pi;
        end
    end
end

% ヘルパー関数 (ファイル外またはメソッド外)
function s = calc_rot_str(lam)
    if lam > 0, s='CW (Right)'; else, s='CCW (Left)'; end
end