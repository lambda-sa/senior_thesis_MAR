classdef ParafoilPathPlanner < handle
    % PARAFOILPATHPLANNER (Based on Original Logic + Pure Dubins Fixes)
    
    properties
        AtmoModel
        ResultData      
        FinalError
        StartV
        
        % パラメータ
        V0 = 15.0; 
        R_fixed = 50.0;
        MinLoiterAngle = 0;
        
        % ★追加: 助走距離
        RunUpDistance = 100.0; 
        
        WindVector = [0; 0; 0];
        EnableBankSpeedCorrection = true;
    end
    
    methods
        function set_speed_correction(obj, enable_flag)
            obj.EnableBankSpeedCorrection = enable_flag;
        end
        function obj = ParafoilPathPlanner(atmo_model)
            obj.AtmoModel = atmo_model;
        end
        function set_min_loiter_turn(obj, num_turns)
            obj.MinLoiterAngle = num_turns * 2 * pi;
        end
        % =========================================================
        % オリジナルの最適化ロジック (そのまま維持)
        % =========================================================
        function chosen_dir = plan_optimal_trajectory(obj, start_3d, target_3d, land_deg, L_final, V0, glide_ratio, R_fixed)
            obj.V0 = V0;
            obj.R_fixed = R_fixed;
            fprintf('--- Path Planning Optimization (R=%.1fm) ---\n', R_fixed);
            
            [resLL, errLL, lenLL] = obj.try_combination('L', 'L', start_3d, target_3d, land_deg, L_final, V0, glide_ratio, R_fixed);
            [resRR, errRR, lenRR] = obj.try_combination('R', 'R', start_3d, target_3d, land_deg, L_final, V0, glide_ratio, R_fixed);
            
            validLL = abs(errLL) < 10; validRR = abs(errRR) < 10;
            if ~validLL && ~validRR
                [resLR, errLR, lenLR] = obj.try_combination('L', 'R', start_3d, target_3d, land_deg, L_final, V0, glide_ratio, R_fixed);
                [resRL, errRL, lenRL] = obj.try_combination('R', 'L', start_3d, target_3d, land_deg, L_final, V0, glide_ratio, R_fixed);
                candidates = [struct('res',resLL,'err',errLL,'len',lenLL,'valid',validLL), ...
                              struct('res',resRR,'err',errRR,'len',lenRR,'valid',validRR), ...
                              struct('res',resLR,'err',errLR,'len',lenLR,'valid',abs(errLR)<10), ...
                              struct('res',resRL,'err',errRL,'len',lenRL,'valid',abs(errRL)<10)];
            else
                candidates = [struct('res',resLL,'err',errLL,'len',lenLL,'valid',validLL), ...
                              struct('res',resRR,'err',errRR,'len',lenRR,'valid',validRR)];
            end
            
            valid_idx = find([candidates.valid]);
            if isempty(valid_idx)
                [~, best_idx] = min(abs([candidates.err]));
            else
                [~, min_len_idx] = min([candidates(valid_idx).len]);
                best_idx = valid_idx(min_len_idx);
            end
            
            best = candidates(best_idx);
            obj.ResultData = best.res.data;
            obj.FinalError = best.err;
            obj.StartV = best.res.data.V_start;
            chosen_dir = best.res.l_dir;
            fprintf('  >>> Selected: %s-Loiter (DubinsLen: %.1f, Err: %.1f)\n', chosen_dir, best.len, best.err);
        end
        
        function [res, final_err, dubins_len] = try_combination(obj, l_dir, d_dir, start_3d, target_3d, land_deg, Lf, V0, gr, R)
            h0 = start_3d(3); step = 0.5; target_z = target_3d(3); tan_g_str = -1.0 / gr;
            cost_func = @(alpha) obj.calc_core(alpha, start_3d, target_3d, land_deg, Lf, step, V0, h0, R, tan_g_str, l_dir, d_dir) - target_z;
            
            best_alpha = 0;
            try
                min_a = obj.MinLoiterAngle;
                z_at_min = obj.calc_core(min_a, start_3d, target_3d, land_deg, Lf, step, V0, h0, R, tan_g_str, l_dir, d_dir);
                if z_at_min >= target_z
                     % 探索初期値の推定 (Run-up考慮)
                    z_run_loss = obj.RunUpDistance * abs(tan_g_str);
                    h_avg = (h0 - z_run_loss + target_z)/2;
                    g = obj.AtmoModel.get_gravity(h_avg);
                    rho0 = obj.AtmoModel.get_density(h0/1000);
                    rho_avg = obj.AtmoModel.get_density(h_avg/1000);
                    V_avg = V0 * sqrt(rho0 / rho_avg);
                    sigma_avg = atan(V_avg^2 / (g * R));
                    tan_g_avg = tan_g_str / cos(sigma_avg);
                    guess_add = (z_at_min - target_z) / (R * abs(tan_g_avg));
                    guess = min_a + guess_add;
                    best_alpha = fzero(cost_func, [min_a, max(min_a + 4*pi, guess*5)], optimset('Display','off','TolX',1e-4));
                end
            catch
                best_alpha = 0;
            end
            [z_fin, data] = obj.calc_core(best_alpha, start_3d, target_3d, land_deg, Lf, step, V0, h0, R, tan_g_str, l_dir, d_dir);
            res.data = data; res.l_dir = l_dir; res.d_dir = d_dir;
            final_err = z_fin - target_z;
            
            if isempty(data.dubins.x)
                dubins_len = inf; 
            else
                % 厳密な長さを計算
                dubins_len = sum(sqrt(diff(data.dubins.x).^2 + diff(data.dubins.y).^2));
            end
        end
        
        % =========================================================
        % ★★★ 修正版 calc_core ★★★
        % オリジナルのロジックを維持しつつ、Run-upとKappa出力を追加
        % =========================================================
        function [final_z, data] = calc_core(obj, alpha, s3d, t3d, land_deg, Lf, step, V0, h0, R, tan_g_str, l_dir, d_dir)
            
            rho0 = obj.AtmoModel.get_density(h0/1000);
            g_ref = obj.AtmoModel.get_gravity(h0);
            
            % シミュレーションカーソル
            curr = struct('x',s3d(1), 'y',s3d(2), 'z',s3d(3), 'yaw',s3d(4));
            current_time = 0;
            data.V_start = V0;
            
            % ----------------------------------------------------
            % 0. Run-up (助走区間) - 新規追加
            % ----------------------------------------------------
            rx=[]; ry=[]; rz=[]; rt=[]; rpsi=[]; rk=[];
            dist_run = 0;
            while dist_run < obj.RunUpDistance
                h_now = max(0, curr.z);
                rho = obj.AtmoModel.get_density(h_now/1000);
                V_TAS = V0 * sqrt(rho0 / rho);
                dz_ds = tan_g_str; % バンクなし
                
                rx(end+1)=curr.x; ry(end+1)=curr.y; rz(end+1)=curr.z;
                rt(end+1)=current_time; rpsi(end+1)=curr.yaw; rk(end+1)=0;
                
                curr.x = curr.x + step * cos(curr.yaw);
                curr.y = curr.y + step * sin(curr.yaw);
                curr.z = curr.z + step * dz_ds;
                current_time = current_time + step / V_TAS;
                dist_run = dist_run + step;
            end
            data.runup = struct('x',rx, 'y',ry, 'z',rz, 't',rt, 'psi',rpsi, 'kappa',rk);
            
            % ----------------------------------------------------
            % 1. Loiter (定常旋回) - オリジナル改修
            % ----------------------------------------------------
            lx=[]; ly=[]; lz=[]; lt=[]; lpsi=[]; lk=[];
            
            % 旋回方向の符号 (NED: 右=正, 左=負)
            % 元コード: L_dir -> l_sign=-1 (yawが増える?減る?確認)
            % 通常、yaw += d_ang は数学的正(左)。NEDではyawは右回りが正。
            % ここでは「NED座標で統一」するため、以下のように設定
            if strcmp(l_dir, 'L')
                k_loiter = -1.0/R; % 左旋回 (NEDで負)
                d_ang_sign = -1.0; % NEDでyawを減らす
            else
                k_loiter = 1.0/R;  % 右旋回 (NEDで正)
                d_ang_sign = 1.0;  % NEDでyawを増やす
            end
            
            tot = 0;
            while tot < alpha
                if curr.z <= 0, final_z = -9999; data.loiter.x=[]; data.dubins.x=[]; data.final.x=[]; return; end
                
                h_km = max(0, curr.z/1000);
                rho = obj.AtmoModel.get_density(h_km);
                V_TAS = V0 * sqrt(rho0 / rho);
                
                % バンクによる沈下増
                tan_phi = abs(k_loiter) * V_TAS^2 / g_ref;
                cos_phi = 1.0 / sqrt(1 + tan_phi^2);
                dz_ds = tan_g_str / cos_phi;
                
                % 保存
                lx(end+1)=curr.x; ly(end+1)=curr.y; lz(end+1)=curr.z; 
                lt(end+1)=current_time; lpsi(end+1)=curr.yaw; lk(end+1)=k_loiter;
                
                % ステップ移動
                move = step;
                if tot + step/R > alpha, move = (alpha - tot)*R; end
                
                d_ang = (move / R); % 角度変化量(絶対値)
                
                curr.x = curr.x + move * cos(curr.yaw);
                curr.y = curr.y + move * sin(curr.yaw);
                curr.z = curr.z + move * dz_ds;
                curr.yaw = curr.yaw + d_ang_sign * d_ang; % NED方向へ更新
                
                current_time = current_time + move / (V_TAS * cos_phi);
                tot = tot + d_ang;
            end
            data.loiter = struct('x',lx, 'y',ly, 'z',lz, 't',lt, 'psi',lpsi, 'kappa',lk);
            
            % ----------------------------------------------------
            % 2. Dubins - オリジナルの dubins_solve を使用して再積分
            % ----------------------------------------------------
            psi_land = deg2rad(land_deg);
            fix_x = t3d(1) - Lf*cos(psi_land); 
            fix_y = t3d(2) - Lf*sin(psi_land);
            
            % 元のSolverを呼ぶ (数学座標で計算される可能性があるため注意)
            % dubins_path_planning は通常「最短経路」を返す
            % ここでは始点・終点・曲率半径を与えて、モードと長さを取得するのが目的
            [~, ~, ~, mode, lengths] = obj.dubins_solve(...
                [curr.x, curr.y, mod(curr.yaw, 2*pi)], ...
                [fix_x, fix_y, psi_land], ...
                1/R, step, d_dir);
            
            if isempty(mode)
                final_z = -99999; data.dubins.x=[]; data.final.x=[]; return; 
            end
            
            dx=[]; dy=[]; dz=[]; dt=[]; dpsi=[]; dk=[];
            
            % Solverの結果(長さとモード)を使って、自前で積分する
            % これにより形状崩れを防ぎ、kappaを正確に出す
            for i = 1:3
                seg_len = lengths(i);
                seg_mode = mode{i}; 
                
                % NEDの曲率
                if strcmp(seg_mode, 'L'), seg_k = -1.0/R;
                elseif strcmp(seg_mode, 'R'), seg_k = 1.0/R;
                else, seg_k = 0; end
                
                dist_in = 0;
                while dist_in < seg_len
                    h_now = max(0, curr.z);
                    rho = obj.AtmoModel.get_density(h_now/1000);
                    V_TAS = V0 * sqrt(rho0 / rho);
                    
                    if abs(seg_k) > 1e-6
                        tan_phi = abs(seg_k) * V_TAS^2 / g_ref;
                        cos_phi = 1.0 / sqrt(1 + tan_phi^2);
                        dz_ds = tan_g_str / cos_phi;
                    else
                        cos_phi = 1.0;
                        dz_ds = tan_g_str; 
                    end
                    
                    d_step = step;
                    if dist_in + d_step > seg_len, d_step = seg_len - dist_in; end
                    
                    dx(end+1)=curr.x; dy(end+1)=curr.y; dz(end+1)=curr.z; 
                    dt(end+1)=current_time; dpsi(end+1)=curr.yaw; dk(end+1)=seg_k;
                    
                    curr.x = curr.x + d_step * cos(curr.yaw);
                    curr.y = curr.y + d_step * sin(curr.yaw);
                    curr.z = curr.z + d_step * dz_ds;
                    curr.yaw = curr.yaw + d_step * seg_k;
                    
                    current_time = current_time + d_step / (V_TAS * cos_phi);
                    dist_in = dist_in + d_step;
                end
            end
            data.dubins = struct('x',dx, 'y',dy, 'z',dz, 't',dt, 'psi',dpsi, 'kappa',dk);
            
            % ----------------------------------------------------
            % 3. Final - 直線
            % ----------------------------------------------------
            df = 0:step:Lf;
            fx = curr.x + df*cos(psi_land); 
            fy = curr.y + df*sin(psi_land); 
            fz = curr.z + df*tan_g_str;
            ft = zeros(size(df)); ft(1)=current_time;
            
            % 時間計算
            for k=2:length(df)
                 h_now = max(0, fz(k-1));
                 rho = obj.AtmoModel.get_density(h_now/1000);
                 V_TAS = V0 * sqrt(rho0 / rho);
                 ft(k) = ft(k-1) + (df(k)-df(k-1))/V_TAS;
            end
            
            fpsi = repmat(psi_land, size(df));
            fkappa = zeros(size(df));
            
            data.final = struct('x',fx, 'y',fy, 'z',fz, 't',ft, 'psi',fpsi, 'kappa',fkappa);
            final_z = fz(end);
        end
        
        % 既存ヘルパー (変更なし)
        function [px, py, pyaw, mode, lengths] = dubins_solve(~, s, e, c, step, start_cons)
             [px, py, pyaw, mode, lengths, ~] = dubins_path_planning(s, e, c, 1.0, step, start_cons);
        end
        
        function plan_simple_physics_based(obj, type, duration, start_pos, V_EAS_trim, glide_ratio, bank_angle_deg)
             % (以前提示したコードと同じ内容であればここに記述。省略時は元のファイルを使用)
        end
    end
end